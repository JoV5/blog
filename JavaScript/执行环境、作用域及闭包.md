> 摘自《JavaScript高级程序设计》

## 执行环境及作用域

**执行环境**（execution context，也称为**环境**）是JavaScript最为重要的一个概念。执行环境定义了变量和函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的**变量对象**(variable object)，环境中定义的素有变量和函数都保存在这个对象中。我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

全局执行环境是最外围的一个执行环境。在Web浏览器中，全局执行环境是Window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出---例如关闭网页或浏览器---时才会被销毁）。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的执行环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建变量对象的一个**作用域链**（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其**活动对象**（activation object）作为变量对象。活动对象在最开始只包含一个变量，即arguments对象，（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链的最后一个对象。

标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。

### 延长作用域链
虽然执行环境的类型总共只有两种---全局和局部（函数），但还是有其他办法来延长作用域链。因为有些语句可以在作用域链前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有以下两种情况：
1. `try-catch`语句的`catch`块：`catch`语句会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
2. `with`语句：它会将指定的对象添加到作用域链中。


## 垃圾收集
JavaScript具有自动垃圾收集机制，也就是说，在执行环境会负责管理代码执行过程中使用的内存。这种垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的手机时间），周期性地执行这一操作。

垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。标记无用变量的策略可能会因实现而异，通常由两个策略：

### 标记清除
JavaScript中最常用的垃圾收集方式是**标记清除**（mark-and-swap）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。当变量离开环境时，则将其标记位“离开环境”。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量所引用的变量的标记。而在此之后再被加上的标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并收回它们所占用的内存空间。

### 引用计数
引用计数的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM对象）时，这种算法可能导致问题。当代码中存在循环引用现象时，“引用计数”算法就会导致问题。


## 闭包
闭包是指有权访问另一个函数作用域中的变量的函数。

当某个函数第一次被调用时，会创建一个执行环境（execution context）及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（即[[Scope]]）。然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第二位···直到作为作用域链终点的全局执行环境。在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。

后台的每个执行环境都有一个表示变量的对象。全局环境的对象始终存在，而局部环境的变量对象，则只在函数执行过程中存在。在创建局部函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部[[Scope]]属性中，在调用时，会为该函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并推入执行环境作用域链的前端。显然，作用域链本质上是一个指向变量对象的指针链表，它只会引用但不实际包含变量对象。

无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量，一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况有所不同。

在一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域中。因此内部函数的作用域链中，实际上会包含外部函数的活动对象。在内部函数从外部函数中返回后，它的作用域链被初始化为包含外部函数的活动对象和全局对象。这样，内部函数就可以访问在外部函数中定义的所有变量。更为重要的是，外部函数在执行完毕后，其活动对象不会被销毁，因为内部函数的作用域链仍然在引用这个活动对象。换句话说，当外部函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到内部函数被销毁后，外部函数的活动对象才会被销毁。

> 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。虽然V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存，但仍应谨慎使用。

### 闭包与变量
闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的变量。

### 关于this对象
this对象是在运行时基于函数的执行环境绑定的。匿名函数的执行环境具有全局性，因此其this通常指向window。但有时候由于编写闭包的方式不同，这一点可能不那么明显。

### 内存泄漏

