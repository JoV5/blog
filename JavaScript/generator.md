# Generator（生成器）
## 打破完整运行
JavaScript开发者在代码中几乎普遍依赖的一个假定：一个函数一旦开始执行，就会运行到结束，期间不会有其他代码能够打断它并插入其间。不过ES6引入了一个新的函数类型，它并不符合这种运行到结束的特性，这类新的函数被称为生成器。

生成器就是一类特殊的函数，可以多次启动和停止。

### 输入和输出
生成器函数是一个特殊的函数，但它仍然是一个函数，这意味着它仍然有一些基本的特性没有改变。比如，它仍然接受参数（即输入），也能够返回值（即输出）。
```js
function *foo(x, y) {
    return x * y;
}

var it = foo(6, 7);

var res = it.next();

res.value = 42;
```
上面，我们只是创建了一个迭代器对象，把它付给了一个变量it，用于控制生成器`*foo(..)`。然后调用`it.next()`，指示生成器`*foo(..)`从当前位置开始继续运行，停在下一个yield处或者直到生成器结束。

这个`next(..)`调用的结果是一个对象，它有一个value属性，持有`*foo(..)`返回的值（如果有的话）。换句话说，yield会导致生成器在执行过程中发送出一个值，有点类似于中间的return。

1. 迭代消息传递

    除了能够接受参数并提供返回值之外，生成器甚至提供了强大的内建消息输入输出能力。，通过`yield`和`next(..)`实现。

    当遇到一个`yield`表达式，它就会在这一点上暂停，并在本质上要求调用代码为`yield`表达式提供一个结果值。
2. 两个问题的故事

    第一个`yield`基本上是提出了一个问题：“这里我应该插入什么值？”。

    消息是双向传递的 -- `yield..`作为一个表达式可以发出消息响应`next(..)`调用，`next(..)`也可以向暂停的yield表达式发送值。

    第一个`next()`调用（没有参数的）基本上就是在提出一个问题：“生成器 `*foo(..)`要给我的下一个值是什么”。最后一个`next()`调用再次提出问题，但是不再由`yield`回答，而是由`return`。

### 多个迭代器
从语法使用的方面来看，通过一个迭代器控制生成器的时候，似乎是在控制声明的生成器函数本身。但有一个细微之处容易忽略：每次构建一个*迭代器*，实际上就隐式构建了生成器的一个实例，通过这个*迭代器*来控制的是这个生成器实例。

同一个生成器的多个实例可以同时运行，它们甚至可以彼此交互。


## 生成器产生值
### 生产者与迭代器
*迭代器*是一个定义良好的接口，用于从一个生产者一步步得到一系列值。JavaScript迭代器的接口，与多数语言类似，就是每次想要从生产者得到下一个值得时候调用`next()`。

`next()`调用返回一个对象。这个对象有两个属性：done是一个boolean值，标识*迭代器*的完成状态；value中放置迭代值。

ES6还新增了一个`for..of`循环，这意味着可以通过原生循环语法自动迭代标准*迭代器*。`for..of`循环在每次迭代中自动调用`next()`，它不会向`next()`传入任何值，并且会在接收到`done:true`之后自动停止。

除了构造自己的*构造器*，许多JavaScript的内建数据结构（从ES6开始），比如array，也有默认的*迭代器*，不过一般的object是故意不像array一样有默认的迭代器。

### iterable
iterable（可迭代），即指一个包含可以在其值上迭代的迭代器的对象。

从ES6开始，从一个iterable中提取迭代器的方法是：iterable必须支持一个函数，其名称是专门的ES6符号之`Symbol.iterable`。调用这个函数时，它会返回一个迭代器。

`for..of`循环自动调用它的`Symbol.iterable`函数来构建一个迭代器。我们也可以手工调用这个函数，然后使用它返回的迭代器。

### 生成器迭代器
可以把生成器看做一个值得生产者，我们通过迭代器接口的`next()`调用一次提取出一个值。严格来说，生成器并不是iterable，当你执行一个生成器，就得到一个迭代器。

#### 停止生成器
`for..of`循环的“异常结束”（也就是提前终止），通常由break、return或者未捕获异常引起，会向生成器的迭代器发送一个信号使其终止。在循环正常结束之后，`for..of`循环也会向迭代器发送这个信号。

尽管`for..of`循环会自动发送这个信号，但你可能会希望向一个迭代器手工发送这个信号，可以通过调用'return(..)'实现这一点。


## 异步迭代生成器
从本质上而言，我们把异步作为实现细节抽象出去，使得我们可以以同步顺序的形式追踪流程控制：“发出一个Ajax请求，等它完成之后打印出响应结果。”并且，当然，我们只在这个流程控制中表达了两个步骤，而这种能力是可以无限扩展的，以便我们无论需要多少步骤都可以表达。

### 同步处理错误
生成器`yield`暂停的特性使我们不仅能够从异步函数调用得到看似同步的返回值，还可以同步捕获来自这些一步函数调用的错误。

也可以通过`throw(..)`手工抛出一个错误，而不是通过触发异常。


## 生成器 + Promise
### 支持Promise的Generator Runner
生成器yield出Promise，然后其控制生成器的迭代器来执行它，直到结束。

#### ES7：async与await？
一类新的函数：async函数。不再用yield出Promise，而是用await等待它决议。

如果你await了一个Promise，async就会自动获知要做什么，它会暂停这个函数（就像生成器一样），直到Promise决议。调用async函数会自动返回一个promise。在函数完全结束之后，这个promise会决议。

### 生成器中的Promise并发
Promise所有的并发能力在生成器+Promise方法中可以使用。

#### 隐藏的Promise
作为一个风格的提醒：要注意你的`生成器`内部包含了多少Promise逻辑。我们介绍使用生成器实现异步的方法全部要点在于创建简单、顺序、看似同步的代码，将异步细节尽可能隐藏起来。

## 生成器委托
yield * 暂停了迭代控制，而不是生成器控制。当你在生成器中调用另一个生成器时，yield会委托到了另一个生成器的迭代器

### 为什么委托
yield委托的主要目的时代码组织，以达到与普通函数调用的对称。

### 消息委托
yield委托不止用于迭代器控制工作，也用于双向消息传递工作，并且错误和异常也是双向传递的。

### 异步委托

### 递归委托
yield委托可以跟踪任意多委托步骤，只要你把他们连在一起。甚至可以使用yield委托实现异步的生成器递归，即一个yield委托到它自身的生成器。


## 生成器并发


## 形实转换程序
*形实转换程序*（thunk），是指一个用于调用另一个函数的函数，没有任何参数。换句话说，用一个函数定义封装函数调用，包括需要的任何参数，来定义这个调用的执行，那么这个封装函数就是一个形实转换程序