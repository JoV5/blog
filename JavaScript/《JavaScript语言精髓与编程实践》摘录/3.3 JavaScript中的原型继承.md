## 3.3 JavaScript中的原型继承
“面向对象”有三个基本特性，即封装、继承和多态。一般来说，三个特性都完全满足的话。我
们称为“面向对象语言”，而满足其中部分特性的语言为“基于对象语言”。  
“对象系统”的继承特性，有三种实现方案，包括基于类（class-based）、基于原型（prototype-based）
和基于元类（metaclass-based）。JavaScript中使用原型继承来实现对象系统。因此JavaScript
中么有“类（Class）”，而采用一种名为“构造器（Constructor）”的机制来实现类的某些功用。
为了叙述方便，会用“对象（类）”来表明类的特性，而用“对象”（或“实例”、“共享对象”）来
表明单一一个对象的特性。在陈述“对象（类）”的特性时，相当于讲述由构造器或有构造机制带
来的特性。

### 3.3.1 空对象（null）与空的对象
在JavaScript中，空的对象是整个原型继承的根基。  
“空对象（null）”是作为一个保留字存在的。null不是“空的对象”，而是代表这样一个对象：
* 属于对象类型
* 对象是空值  

因为是对象类型，所以甚至可以列举（for...in）它；又因为它是空值，没有任何方法和属性
，因而列举不到内容。  
null对象也可以参与运算，例如“+（加法和字符串连接）”或“-（减法）”运算。但因为他没有
属性也没有方法，同时没有原型，所以这些相关的调用都会失败。由于它并不是Object()构造
器（或其子类）实例而来，因此instanceof运算会返回false。  
所谓“空的对象”（也称为裸对象、空白对象），就是一个标准的、通过Object()够早的对象实
例如我们使用：
```js
obj = new Object();
```
来得到obj的实例。此外对象直接量也会隐式地调用Object()来构造实例，因此下面的代码也可
得到一个“空的对象”：
```js 
obj = {};
```
空的对象具有“对象”的一切特性。因此可以存取预定义属性和方法，而instanceof运算也会返
回true。

### 3.3.2 原型继承的基本性质
就JavaScript的语言和对象系统的实现来讲，对象（Object Instance）并没有原型，而构造
器有原型，属性“<构造器>.prototype”指向原型。对象只有“构造自某个原型”的问题，并不存
在“持有（或拥有）某个原型”的问题。  
原型其实也是一个对象实例。原型的含义是指：如果构造器有一个原型对象A，则由该构造器创
建的实例（Instance）都必然复制自A。这里的“复制”就存在了多种可能性，由此引申出了动
态绑定和静态绑定等问题。先不考虑“复制”如何被实现，而只需先认识到：由于实例复制自对象
A，所以势力必然继承了A的所有属性、方法和其他性质。  
“原型也是对象实例”是一个最关键的性质，这是它与“类继承体系”在本质上的不同。对于类继承
来说，类不必是“对象”，因此类也不必具有对象的性质。举例来说，“类”可以是一个内存块，也
可以是一段描述文本，而不必是一个有对象特性（例如可以调用方法或存取属性）的结构。

### 3.3.3 空的对象是所有对象的基础
```js 
// 取原型对象
proto = Object.prototype;

// 列举对象成员并计数
var num = 0;
for (var n in proto) {
    num++;
}

// 显示计数：0
alert(num);
```
可见，Object()构造器的原型就是一个空的对象。
这意味着下面两行代码，都是自Object.prototype上复制出一个“对象”的映像--它们也是“空
的对象”；
```js
obj1 = new Object();
obj2 = {};
```
因此对象的“构建过程”可以被简单地映射为“复制”。

### 3.3.4 构造复制？写时复制？还是读遍历
上面假设没构造一个实例，都从原型中复制出一个实例来，新的实例与原型占用了相同的内存空
间。这虽然使得obj1、obj2与它们的原型“完全一致”，单页非常不经济--内存空间的消耗会急
速增加。  
另一个策略来自于一个欺骗系统的技术：写时复制。这种欺骗的典型实例就是操作系统中的动态
链接库（DLL），它的内存区总是写时复制。在读取的时候，只需要顺着指示去读原型，当需要
写对象的属性时，我们就复制一个原型的映像出来，并使以后的操作指向该映像就行了。  
这种方式的优点就是我们只在第一次写的时候会用一些代码来分配内存，并带来一些代码和内存
上的开销。但此后就不在有这种开销了，因为访问映像与访问原型的效率是一致的。不过对于
经常进行写操作的系统来说，这种方法并不比上一种方法经济。  
JavaScript采用了第三种方法：把写复制的粒度从原型变成了成员。这种方法的特点是：仅当
写某个实例的成员时，将成员的信息复制到实例映像中。这样一来，再初始构造该对象时，局面
与写时复制机制的原型继承一致，但写对象属性时，会产生一个名为value的属性值，放在实例
对象的成员列表中。我们发现，实例仍然是一个指向原型的引用，在操作过程中也没有与原型相
同大小的对象实例创建出来。这样，写操作并不导致大量的内存分配，因此内存的使用上就显得
经济了。但实例需要维护一张成员列表。这个成员列表指向在实例中发生了修改的成员名、值与
类型。这张表是否与原型成员一致并不重要，只需要遵循两条规则。
* 规则1：保证读取时被首先访问到。
* 规则2：如果在对象中没有指定属性，则尝试遍历对象的整个原型链，直到原型为空（null）
或找到该属性。  

上面的规则其实是与“对象是什么”没有关系的。这个规则描述的是一种对象的成员的存取规则，
以及存储这些成员时的数据结构约定。存取实例中的属性，比存取原型中的属性效率要高。

### 3.3.5 构造过程：从函数到构造器
函数首先只是函数，尽管它有有个“prototype”程艳，但如果每申明一个函数都“先创建一个对
象实例，并使prototype成员指向它”，那么也并不经济。所以事实上，我们可以认为prototype
在函数初始时根本是无值的，实现上可能如下：
```js
// 设定__proto__是函数内置的成员，get_prototype()是它的读方法
var __proto__ = null;
function get_prototype() {
    if (!__proto__) {
        __proto__ = new Object();
        __proto__.constructor = this;
    }
    return __proto__;
}
```
所以，函数只有在需要引用原型时，才具有构造器的特性。而且函数的原型总是一个标准的、系
统内置的Object()构造器的实例，不过该实例创建后constructor属性总被先赋值为当前函数。
关于这点很容易证明，因为delete运算符总是可以删去当前属性，而让成员存取到父类的属性
值，所以：
```js
function MyObject() {

}

// 1. 显示true，表明原型的构造器总是指向函数自身
alert(MyObject.prototype.constructor == MyObject);

// 2. 删除该成员
delete MyObject,prototype.constructor;

// 3. 删除操作将使该成员指向父类原型中的值
// (显示值true)
alert(MyObject.prototype.constructor == Object);
alert(MyObject.prototype.constructor == new Object().constructor);
```
MyObject.prototype其实是一个普通对象--“new Object()”创建的实例并没有本质区别。
然而当一个函数的prototype有意义之后，它就摇身变成了一个“构造器”。这时，用户试图用
new运算创建它的一个实例，那么引擎就再构造一个对象，并使该对象的原型链接向这个prototype
属性就可以了。因此，函数与构造器并没有明显的界限，其中唯一的区别，只在于原型prototype
是不是一个有意义的值。  
你也可以认为函数的prototype总是有意义的--只是本体以函数存在时它显得多余罢了。你得记住
“构造器的prototype属性总是来自于new Object()产生的实例“这个基本假设。

### 3.3.6 预定属性与方法
由构造过程我们知道，JavaScript中的对象实例本质上只是“一个指向其原型的，并持有一个属
性列表（properties，本文中称之为成员列表）的结构”。  
可见，对象实例本身并没有什么特别的性质，甚至都不像一个“对象”（而像或者说是一个普通的
结构体）。他所有的对象性质，来源于系统对原型的，以及成员列表的理解。而我们前面说过“
空的对象是所有对象的基础“，也就是Object.prototype是所有对象的最顶层的原型。因此我们
所谓的“空的对象”，以及“干净的对象”，只不过是满足以下条件的一个结构：
* ^proto指向Object.prototype
* ^proto指向一个空表  

更进一步的推论：我们所有的“实例”，之所以具有对象的某些性质，是因为它们的共同原型
Object.prototype具有这些性质（Propertities of the Object Prototype Object）。  
下面对这些对象实例的性质做一个分类，这意味着表中所有性质（成员/属性）是每一个对象实
例所必然具备的，它们共同继承自Object.prototype。需要强调的是，其中一些性质并不是“
原型继承所必需的”，而是JavaScript作为“动态语言”所必需的。
##### 表3-7 对象原型所具有的基本性质
| 成员名 | 类型 | 分类 |
| :- | :-: | :-: |
| toString | function | 动态语言 |
| toLocaleString | function | 动态语言|
| valueOf | function | 动态语言 |
| constructor | function | 对象系统：构造
| propertyIsEnumerable | function | 对象系统：属性 
| hasOwnPorperty | function | 对象系统：属性
| isPrototypeOf | function | 对象系统：原型
对于一个具体的构造器，他除了具有上述普通对象的成员之外（因为自身是一个对象），还具有
几个特别的、属于函数的成员（Properties of the Object as a Function）。表3-8对这
些特殊性质做了一个分类。
##### 表3-8 构造器（函数）所具有的特殊成员
| 成员名 | 类型 | 分类 
| - | :-: | :-: 
| call | function | 函数式语言
| apply | function | 函数式语言
| caller | function | 函数式语言
| bind | function | 函数式语言
| arguments | object | 动态语言
| length | number | 动态语言 
| prototype | object | 对象系统：原型 
在ECMAScript 5th中扩展了Object()这个构造器的属性，使之具有一批特殊成员（Properties 
of the Object Constructor）。表3-9列举了这些成员以及它们在本书中的参考内容。
##### 表3-9 ECMAScript 5th中对Object对象进行的扩展
| 成员名 | 类型 | 参考本书章节 | 分类
| :- | :-: | :-: | :-:
| create | function | 3.5.2.2 | 对象系统：构造 
| getPrototypeof | function | 3.3.7.4 | 对象系统：原型
| defineProperty | function | 3.5.2.1 | 对象系统：属性
| defineProperties | function | 3.5.2.1 | 对象系统：属性
| getOwnPropertyDescriptor | function | 3.5.2.1 | 对象系统：属性
| keys | function | 3.5.3.1 | 对象系统：属性
| getOwnPropertyNames | function | 3.5.3.1 | 对象系统：属性
| seal | function | 3.5.3 | 对象系统：属性
| freeze | function | 3.5.3 | 对象系统：属性
| precentsExtensions | function | 3.5.3 | 对象系统：属性
| isSealed | function | 3.5.3 | 对象系统：属性
| isFrozen | function | 3.5.3 | 对象系统：属性
| isExtensible | function | 3.5.3 | 对象系统：属性

### 3.3.7 原型链的维护
#### 3.3.7.1 两个原型链
从表3-8 来看，维护原型链似乎全是构造器的事情，因为只有构造器（函数对象）有一个名为
prototype的成员。但事实并非如此，实例至少应该拥有指向原型的proto属性，这时JavaScript
中的对象系统的基础。不过这个属性不是可见的，我们称之为“内部原型链”，以便和构造器的
prototype所组成的“构造器原型链”（亦即我们通常所说的“原型链”）区分开来。  
构造器通过显示的prototype属性构建了一个原型链，而对象实例也通过内部属性proto构建
了一个原型链，但proto是实例不可访问的内部属性，所以没法从实例开始访问整个原型链。  
解决这个问题的方法是使用obj.constructor属性来维护原型链。

#### 3.3.7.2 constructor属性的维护
一个构造器产生的实例，其constructor属性默认总是指向该构造器。因此，下面的代码将显
示为true：
```js
// 示例1：构造器：constructor属性
function MyObject() {

}
var obj = new MyObject();
alert(object.constructor === MyObject);
```
究其根源，在于构造器（函数）的原型的constructor属性指向了构造器本身，所以下面的代
码也将显示true：
```js
// 续（示例1...）
alert(MyObject.prototype.constructor === MyObject);
```
由此可见，JavaScript事实上已经为构造器维护了原型属性。因此在一般情况下（强调“一般
情况”），我们可以通过实例constructor属性来找到构造器，并进而找到它的原型。如下例：
```js
// （续上例）
alert(MyObject.constructor.prototype);
```
constructor会与原型继承发生冲突，下面两个构造器的prototype.constructor也都毋庸置
疑地、正确地指向了构造器自身：
```js
// 示例2：构造器的constructor属性
function MyObject() {

}
function MyObjectEx() {

}
// 但下面的代码会导致问题
// 构建原型链
MyObjectEx.Prototype = new MyObject();
```
由于重置了MyObjectEx的原型继承属性，那么显然：
```js
MyObjectEx.prototype.constructor = MyObject.prototype.constructor = MyObject;
```
因此在构造原型链之后，整个MyObjectEx就出了问题。
```js
// 续上例
var obj1 = new MyObject();
var obj2 = new MyObjectEx();
alert(obj1.constructor == obj2.constructor);
```
将显示true！obj1与obj2是不同的构造器产生的实例，而它们的constructor属性指向了相同
的构造器。  
问题在于我们给MyObjectEx赋予了一个原型时，应该“修正”该原型的构造器值。一般作如下处理：
```js
// （续上例）
// 方法1：直接构建原型链
MyObjectEx.prototype = new MyObject();
MyObjectEx.prototype.constructor = MyObjectEx;
```
也就是在重置原型链后，在修改原型的constructor属性，使之指向正确的构造器函数。
```js
// 方法2：正确维护constructor以便回溯原型链
function MyObjectEx() {
    this.constructor = MyObjectEx;
}
// 原型链
MyObjectEx.prototype = new MyObject();
```
