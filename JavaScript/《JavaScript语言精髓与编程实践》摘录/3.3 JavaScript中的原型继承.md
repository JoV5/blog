## 3.3 JavaScript中的原型继承
“面向对象”有三个基本特性，即封装、继承和多态。一般来说，三个特性都完全满足的话。我
们称为“面向对象语言”，而满足其中部分特性的语言为“基于对象语言”。  
“对象系统”的继承特性，有三种实现方案，包括基于类（class-based）、基于原型（prototype-based）
和基于元类（metaclass-based）。JavaScript中使用原型继承来实现对象系统。因此JavaScript
中么有“类（Class）”，而采用一种名为“构造器（Constructor）”的机制来实现类的某些功用。
为了叙述方便，会用“对象（类）”来表明类的特性，而用“对象”（或“实例”、“共享对象”）来
表明单一一个对象的特性。在陈述“对象（类）”的特性时，相当于讲述由构造器或有构造机制带
来的特性。

### 3.3.1 空对象（null）与空的对象
在JavaScript中，空的对象是整个原型继承的根基。  
“空对象（null）”是作为一个保留字存在的。null不是“空的对象”，而是代表这样一个对象：
* 属于对象类型
* 对象是空值  

因为是对象类型，所以甚至可以列举（for...in）它；又因为它是空值，没有任何方法和属性
，因而列举不到内容。  
null对象也可以参与运算，例如“+（加法和字符串连接）”或“-（减法）”运算。但因为他没有
属性也没有方法，同时没有原型，所以这些相关的调用都会失败。由于它并不是Object()构造
器（或其子类）实例而来，因此instanceof运算会返回false。  
所谓“空的对象”（也称为裸对象、空白对象），就是一个标准的、通过Object()够早的对象实
例如我们使用：
```js
obj = new Object();
```
来得到obj的实例。此外对象直接量也会隐式地调用Object()来构造实例，因此下面的代码也可
得到一个“空的对象”：
```js 
obj = {};
```
空的对象具有“对象”的一切特性。因此可以存取预定义属性和方法，而instanceof运算也会返
回true。

### 3.3.2 原型继承的基本性质
就JavaScript的语言和对象系统的实现来讲，对象（Object Instance）并没有原型，而构造
器有原型，属性“<构造器>.prototype”指向原型。对象只有“构造自某个原型”的问题，并不存
在“持有（或拥有）某个原型”的问题。  
原型其实也是一个对象实例。原型的含义是指：如果构造器有一个原型对象A，则由该构造器创
建的实例（Instance）都必然复制自A。这里的“复制”就存在了多种可能性，由此引申出了动
态绑定和静态绑定等问题。先不考虑“复制”如何被实现，而只需先认识到：由于实例复制自对象
A，所以势力必然继承了A的所有属性、方法和其他性质。  
“原型也是对象实例”是一个最关键的性质，这是它与“类继承体系”在本质上的不同。对于类继承
来说，类不必是“对象”，因此类也不必具有对象的性质。举例来说，“类”可以是一个内存块，也
可以是一段描述文本，而不必是一个有对象特性（例如可以调用方法或存取属性）的结构。

### 3.3.3 空的对象是所有对象的基础
```js 
// 取原型对象
proto = Object.prototype;

// 列举对象成员并计数
var num = 0;
for (var n in proto) {
    num++;
}

// 显示计数：0
alert(num);
```
可见，Object()构造器的原型就是一个空的对象。
这意味着下面两行代码，都是自Object.prototype上复制出一个“对象”的映像--它们也是“空
的对象”；
```js
obj1 = new Object();
obj2 = {};
```
因此对象的“构建过程”可以被简单地映射为“复制”。

### 3.3.4 构造复制？写时复制？还是读遍历
上面假设没构造一个实例，都从原型中复制出一个实例来，新的实例与原型占用了相同的内存空
间。这虽然使得obj1、obj2与它们的原型“完全一致”，单页非常不经济--内存空间的消耗会急
速增加。  
另一个策略来自于一个欺骗系统的技术：写时复制。这种欺骗的典型实例就是操作系统中的动态
链接库（DLL），它的内存区总是写时复制。在读取的时候，只需要顺着指示去读原型，当需要
写对象的属性时，我们就复制一个原型的映像出来，并使以后的操作指向该映像就行了。  
这种方式的优点就是我们只在第一次写的时候会用一些代码来分配内存，并带来一些代码和内存
上的开销。但此后就不在有这种开销了，因为访问映像与访问原型的效率是一致的。不过对于
经常进行写操作的系统来说，这种方法并不比上一种方法经济。  
JavaScript采用了第三种方法：把写复制的粒度从原型变成了成员。这种方法的特点是：仅当
写某个实例的成员时，将成员的信息复制到实例映像中。这样一来，再初始构造该对象时，局面
与写时复制机制的原型继承一致，但写对象属性时，会产生一个名为value的属性值，放在实例
对象的成员列表中。我们发现，实例仍然是一个指向原型的引用，在操作过程中也没有与原型相
同大小的对象实例创建出来。这样，写操作并不导致大量的内存分配，因此内存的使用上就显得
经济了。但实例需要维护一张成员列表。这个成员列表指向在实例中发生了修改的成员名、值与
类型。这张表是否与原型成员一致并不重要，只需要遵循两条规则。
* 规则1：保证读取时被首先访问到。
* 规则2：如果在对象中没有指定属性，则尝试遍历对象的整个原型链，直到原型为空（null）
或找到该属性。  

上面的规则其实是与“对象是什么”没有关系的。这个规则描述的是一种对象的成员的存取规则，
以及存储这些成员时的数据结构约定。存取实例中的属性，比存取原型中的属性效率要高。

### 3.3.5 构造过程：从函数到构造器
函数首先只是函数，尽管它有有个“prototype”程艳，但如果每申明一个函数都“先创建一个对
象实例，并使prototype成员指向它”，那么也并不经济。所以事实上，我们可以认为prototype
在函数初始时根本是无值的，实现上可能如下：
```js
// 设定__proto__是函数内置的成员，get_prototype()是它的读方法
var __proto__ = null;
function get_prototype() {
    if (!__proto__) {
        __proto__ = new Object();
        __proto__.constructor = this;
    }
    return __proto__;
}
```
所以，函数只有在需要引用原型时，才具有构造器的特性。而且函数的原型总是一个标准的、系
统内置的Object()构造器的实例，不过该实例创建后constructor属性总被先赋值为当前函数。
关于这点很容易证明，因为delete运算符总是可以删去当前属性，而让成员存取到父类的属性
值，所以：
```js
function MyObject() {

}

// 1. 显示true，表明原型的构造器总是指向函数自身
alert(MyObject.prototype.constructor == MyObject);

// 2. 删除该成员
delete MyObject,prototype.constructor;

// 3. 删除操作将使该成员指向父类原型中的值
// (显示值true)
alert(MyObject.prototype.constructor == Object);
alert(MyObject.prototype.constructor == new Object().constructor);
```
MyObject.prototype其实是一个普通对象--“new Object()”创建的实例并没有本质区别。
然而当一个函数的prototype有意义之后，它就摇身变成了一个“构造器”。这时，用户试图用
new运算创建它的一个实例，那么引擎就再构造一个对象，并使该对象的原型链接向这个prototype
属性就可以了。因此，函数与构造器并没有明显的界限，其中唯一的区别，只在于原型prototype
是不是一个有意义的值。  
你也可以认为函数的prototype总是有意义的--只是本体以函数存在时它显得多余罢了。你得记住
“构造器的prototype属性总是来自于new Object()产生的实例“这个基本假设。