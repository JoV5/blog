## 5.4 重写
JavaScript的重写是一个代码执行期的行为--在代码的语法分析期，引擎既不对重写行为进行任何预期，也不对其进行限制。因此，重写可能发生的问题之一就是在运行中会发现冲突或因为错误、以外的重写而导致不可预料的代码逻辑错误。  
重写是JavaScript中各种语言特性相互作用额黏合剂，例如对象系统就依赖原型重写与原型修改来构造大型的继承系统。  

### 5.4.1 原型继承
原型继承的一些问题难以规避，例如原型重写。正因为原型时可以重写的，所以事实上你可以用同一个构造器构造出两个完全不同的实例。
这是因为一个构造器的原型被重写，则意味着“此前的一个原型被废弃”。于是，在由该构造器所构造的实例中：
* 旧的实例使用这个被废弃的原型，并受到该原型的影响。
* 新创建的实例则使用重写后的原型，受新原型的影响。  

由此可见：重写的存在导致同一个构造器可能有多套原型系统。这虽然给系统带来了非常大的复杂性，但在本质上并没有违反原型继承的任何规则。

### 5.4.2 构造器重写
显式的构造器修改也会导致继承关系丢失，不过可以说是一种代码逻辑上的假象。

#### 5.4.2.1 语法声明与语句含义不一致的问题

#### 5.4.2.2 对象检测的麻烦

typeof instanceof

#### 5.4.2.3 构造器的原型（prototype属性）不受重写影响
构造器的原型创建自系统内部的对象系统，而不是可被外部覆盖的标识符Object，因此原型总能被创建。  
所以构造器的原型属性，并不受Object()类的重写影响，它总是创建一个系统引擎中的对象构造器。  

#### 5.4.2.4 “内部对象系统”不受影响
当用户试图通过重写Object()来创建一个“用户对象系统”的时候，他事实上会在这个系统与“内部对象系统”之间遇到一道栅栏。这道栅栏会保证内部对象系统不受任何影响：
* 确保任何构造器的原型总是来自于该PureObject的一个实例。
* PureObject的原型改写与重写可以影响整个对象系统。

#### 5.4.2.5 让用户对象系统内部对象系统
让用户对象系统对内部对象系统产生影响的一个简单方法是“让用户对象系统持有PureObject.prototype”

#### 5.4.2.6 构造器重写对直接量声明的影响
直接量声明总会调用“内部对象系统”来构造函数。  
在构造器重写之后，直接量只与重写前的构造器相关。因此重写不会对直接量声明构成什么影响。

#### 5.4.2.7 构造绑定
重写构造器之后，直接量声明将使用“新构造器的原型”来构造对象，但不会影响到旧的、已构造的对象实例。  
在SpiderMonkey JavaScript中，Object()与Array()的直接量声明总是通过“标识符所对应的构造器的实例”来生成对象实例（在JScript中没有实现构造绑定）。
* （在SpiderMonkey JavaScript中，）对象类型的直接量声明，与它的构造类直接绑定。直接量声明过程本质上就是（对应的）构造类创建实例的过程。  
重写Object()，新的构造器具有如下特性：
```js
// 1.先从引擎内核取出原始的Object构造器
PureObject = Object;
// 2. 重写构造器 
Object = function () {}
// 3.新函数作为构造器时会为它的prototype属性创建一个对象，需要使用原始的Object
Object.prototype = new PureObject();
// 4.该原型的constructor属性应指向函数自身
Object.prototype.constructor = Object;
```
#### 5.4.2.8 内置构造器重写的概述

### 5.4.3 对象成员的重写
严格来说，原型重写是对象成员重写的一种特例。在不考虑宿主情况下，JavaScript对象中的几乎所有成员都可以被重写。与重写prototype属性一样，一些成员的重写是有特殊意义的，例如成员toString与valueOf的重写。而另一部分则没有什么特殊含义，例如重写成员call与apply。  

#### 5.4.3.1 成员重写的检测
hasOwnProperty  
从根本上来说，有效检测一个成员是否重写的关键，在于用户是否维护了一个有效的原型链。当然，如果用户并不检测一个对象的原型是否（相对于其父类）发生了重写，那这种回溯是不必要的。  

#### 5.4.3.2 成员重写的删除
一旦一个属性是在对象的原型中添加的，那么你就不能直接从对象中删除它，而只能从原型（以及其父类的原型）中删除--但是这一过程并不安全，因为它会影响该类创建的其他实例。  

### 5.4.4 宿主对重写的限制
多数不能重写的情况，是出自宿主环境的限制。这种重写限制是否导致异常，也取决于宿主环境。一般来说，重写不会修改引用者的性质。在宿主环境中的重写行为不单单受到引用的限制，也会受到被重写成员的一些性质的限制。常见的性质是“只读”，这种情况下，该成员是不能写的。除此之外，也可能触发某种特别的行为，从而导致重写失败或远离开发人员的预期，比如浏览器环境中的location对象，重写location将切换到新的网址。

### 5.4.5 引擎对重写的限制
JavaScript语言时不支持对关键字的重写。也不能重写直接量。

#### 5.4.5.1 this的重写
“this”引用不能被重写是最常见的引擎对重写的限制。

#### 5.4.5.2 语句语法的重写

#### 5.4.5.3 结构化异常处理中的重写
finally{...}块的“总是被执行”的语法效果的方法，是在try块（因为任意原型）return之前“挂起”try块中的代码行，然后转入finally块代码块执行代码。在挂起return子句的过程中，finally块不能重写return返回的值。

