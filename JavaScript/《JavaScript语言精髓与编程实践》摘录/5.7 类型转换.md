## 5.7 类型转换
JavaScript中数据的类型并不是由变量声明来决定的，而是由它包含什么值来决定的。  由于类型只能在代码执行过程中才能获知，所以JavaScript也就只能采用“运算郭恒中执行某种类型转换规则”来解决不同类型间的运算问题。

### 5.7.1 宿主环境下的特殊类型系统
JavaScript的类型系统在不同的宿主环境下可能存在特殊性。

### 5.7.2 值运算：类型转换的基础
元类型其实只有两类：值类型和引用类型。在这个类型系统中，只有函数与对象是引用类型的，JavaScript的对象系统衍生自元类型Object，函数式语言特性则基于元类型function。  
引用类型自身其实并不参与值类型，对于计算机来说，引用类型的价值是：
* 表示一组数据。
* 提供一组存取数据的规则。
* 在函数中传递与存储引用（标识）。

所谓的类型转换，其实是指：
* 值类型之间的转换
* 将引用类型转换为值类型（以参与运算）

### 5.7.3 隐式转换
我们把通过函数或方法调用，明确地将类型转换为另一类型的称为显式转换。相应的，不通过函数或方法调用的情况，就称为隐式转换。后者主要是指在用户代码不明确指示数据类型的情况下，JavaScript引擎根据代码的上下文推断所需要的数据类型，并完成操作数转换和值运算的过程。这一过程通常发生在表达式运算和某些语句（语义）对数据的强制理解上。

#### 5.7.3.1 运算导致的类型转换
在语法分析期，JavaScript引擎首先解析到运算符，并将运算符操作的运算元（标识符或直接量值）置入语法树--但这一过程并不对运算元的类型做任何的推定。在运行期，引擎执行语法树上（由运算符指定）的运算时，将首先根据运算符所支持的“运算元的类型”进行一次操作数的隐式转换。  
JavaScript运算过程中的隐式类型转换，既受到基于运算符的“类型推定”的影响，又受到基于运算元类型的“运算符推定”的影响。

#### 5.7.3.2 语句（语义）导致的类型转换
比如if语句

### 5.7.4 值类型之间的转换

#### 5.7.4.1 undefined的转换
任何值都不能“转换为undefined”，但反过来却不是。以为undefined实际上也需要参与运算。  
undefined可以转换为特殊数字值NaN、字符串‘undefined’和布尔值false。

#### 5.7.4.2 number的转换
任何值都可以被转换到number类型的值。如果转换得不到一个有效值，那么结果会是一个NaN，而NaN又是一个可以参与数值运算的值。这么处理的目的在于尽量求值而不是弹出异常。  
Number值转换为布尔值时，非零值都转为true，零与NaN都转为false。  
Number值在转换到字符串时有极其复杂的内部规则。因此除非使用显示转换，否则很难保证Number到字符串这一转换的输出格式。但总的来说，以下特殊值被转换为非数值含义的字符串：
* Number.NEGATIVE_INFINITY，转换为‘-Infinity’。
* Number.POSITIVE_INFINITY，转换为‘Infinity’。
* Global.Infinity，转换为‘Infinity’。
* Global.NaN，转换为‘NaN’  

除此之外，其他数值都能被转换为一个有数值含义的字符串。

#### 5.7.4.3 boolean的转换
boolean值的true和false总是被转换为数值1和0。  
boolena值的true和false总是被转换为字符串的“true”和“false”。

#### 5.7.4.4 string的转换
如果一个字符串由数值和不多于一个的小数点构成，那么它总是能被转换为数值。这种情况下，它被当做十进制数处理。  
如果数字由‘0x’（零和x|X）开始作为前缀，且由0~9、A-F、a-f这些字符（不包括小数点）构成，则它总是可以被作为十六进制数转换为数值。前缀0可以用在直接量中，以表示八进制，在字符串中，在（隐式）转换时被忽略。  
在字符串中，有且仅有空字符串能被转换为布尔值false，其他（任何有值的）字符串在转换后都得到true。

#### 5.7.4.5 值类型数据的显示转换
parseInt()支持传入一个值2~36之间的“radix”参数来制定所使用的的进制，如果转换失败，则返回NaN。如果不指定radix，那么将采用数值直接量声明中使用的规则：将有前缀“0x”的处理成十六进制字符串，有前缀“0”的处理成八进制字符串。在隐式转换中前缀“0”并不被识别为八进制。  
parseInt()和parseFloat()另一项特性在于总是尽可能地得到转换结果。即使字符传中只有（前缀的）部分能被转换，那么该转换也将成功进行。

### 5.7.5 从引用到值：深入探究valueOf()方法
如果一个数据是引用类型，切该数据需要进行值运算，那么引擎将先调用它（或它经过包装后的对象）的valueOf()方法求值，然后以该值参与值运算。
但是仍然有一部分引用类型数据不能通过它的valueOf()方法来得到一个有效的值。例如Object、Error、RegExp以及Function对象。在这种“valueOF()返回引用类型”的情况下，引擎会再次调用toString()方法以取得一个字符串值。字符串总是可以以值类型的形式参与运算的，这样就保证了JavaScript内部的任意数据总是可以直接参与值运算。  
（元类型中的）值类型数据在类型转换中并不会调用toString()或valueOf()方法，也不会为此进行包装类操作。

### 5.7.6 到字符串的显式转换
现在我们知道：
* 如果数据是值类型，则直接参与值运算。
* 如果valueOf()返回一个值类型数据，则以该数据参与值运算。
* 使用toString()返回的字符串参与运算。

在JavaScript中的任何一种数据类型，都可以（显式或隐式地）转换换到字符串类型。提供这种能力的前提是：JavaScript约定一切都是对象（undefined值除外），因而必然存在toString()方法以达到转换数据的目的，只不过是由JavaScript引擎来负责调用这个方法而已。

#### 5.7.6.1 重写toString()方法
重写toString()方法很明显地会影响到某种类型到字符串的显示转换。  
要让toString()方法生效，需要让valueOf()返回引用而不是值。

#### 5.7.6.2 从数值到字符串的显式转换
除了使用述职对象的显式方法--标准的toString()方法来转换之外，还可以使用toString()的一种扩展形式：aNumber.toString([radix])。其中radix表示进制。  
Number对象的另外三个方法，分别是：
* toFixed(digits)，使用定点计数法，返回串的小数点后有digits位数字。
* toExponential(digits)，使用指数计数法，使返回串的小数点后有digits位数字。
* toPrecision(precision)，使用定点计数法，返回串包括precision个有效数字（如果整数部分少于precision位，则在小数部分用0补齐），如果整数部分多余precision位，则使用指数计数法，并使小数点后有precision-1个数字。

#### 5.7.6.3 其他类型的显式转换
在JavaScript各种对象中，存在一组以“to”为前缀的方法，这些方法无一例外用于转换为字符串。  

#### 5.7.6.4 序列化
通过字符串作为中介，你可以拥有两个功能相同、但不存在引用关系的函数。类似的这种技术被称为“序列化”与“反序列化”。