## 4.6 闭包
要保证“函数式风格”的纯粹性，就需要强调“在内部保存数据和对外无副作用”这两大特性--
这在JavaScript中都是通过“函数闭包（Function Closure）来实现的”。  
另外在JavaScript中还存在一种特殊的“对象闭包（Object Closure）”，它是与with语句
实现直接相关的一种闭包。

### 4.6.1 闭包与函数实例
闭包（Closure）与函数有着紧密的关系。在JavaScript中，一个函数只是一段静态的代码、
脚本文本，因此它是一个代码书写时，以及编译期的、静态的概念；而闭包则是函数的代码在
运行过程中的动态环境一个运行期的、动态的概念。由于引擎对每个函数建立起独立的上下文
环境，因此当函数被再次执行或者通过某种方法进入函数体内时，就可以得到闭包内的全部信
息。
 
#### 4.6.1.1 什么是闭包
闭包具有两个特点：第一是闭包作为与函数成对的数据，在函数执行过程中处于激活（即可访
问）状态；第二闭包在函数运行结束后，保持运行过程的最终数据状态。因此函数的闭包总的
来说决定了两件事：闭包所对应的函数代码如何访问数据，以及闭包内的数据何时销毁。  
闭包包括的是函数运行的应用、环境（用来查找全局变量的表），以及一个由所有upvalue引
用组成的数组。图4-3说明了这种结构关系。 

###### 图4-3 闭包及其相关概念之间的关系
```JS
function MyFunc() { // 闭包1
    var datat_1 = 123; //          <—|
    var data_2 = new Array(); //   <-|
                              //     |  upvalue
    function func_1() { // 闭包2     ||
        // ...
    }

    function func_n() { // 闭包n
        // ...
    }

    // ...
}
```

图4-3 并不能传达出“闭包是运行期概念”这样的信息，仅能从静态的视觉效果上说明闭包、子
函数闭包、upvalue之间的关系。未能包括的信息包括：
* 在运行过程中，子函数闭包（闭包2~n）可以访问upvalue。
* 同一个函数中的所有子函数（闭包2~n），访问一份相同值得upvalue。

4.6.1.2 什么是函数实例与函数引用
在书写代码的过程中，函数只是一段代码文本。对编译语言来说，这段文本总被编译成确定的代
码，并放在确定的内存位置执行。因此在编译语言里，一段代码文本与运行期的代码实例实际上
是等同的、一对一的概念。有由于函数可以被多个不同的变量应用，所以一个函数的代码块在运
行期可对应多个变量（函数入口地址指针）。  
```JS
function myFunc() {

}

var f1 = myFunc;
var f2 = myFunc;

// 返回值true，表明变量f1与f2指向同一个函数实例，反过来说，也就是f1和f2是
// 该函数实例的多个引用
alert(f1 === f2);
```
在JavaScript中也可以具有这种关系，却并不是单单只有这种关系。更为复杂的情况时：一个
函数代码可以有多份函数实例，一个函数实例可以有多个函数引用。比如
```JS
function MyObject() {
    function func() {
        // ...
    }
    this.doFunc = func;
}

var obj1 = new MyObject();
var obj2 = new MyObject();

// 显示false，表明这是两个不同的函数实例
alert(obj1.doFunc === obj2.doFunc);
// 显示true，表明两个函数实例的代码块完全相同
alert(obj1.doFunc.toString() == obj2.doFunc.toString())
```
这与new运算无关，也与JavaScript的对象系统无关。
```JS
function myFunc() {
    function func() {
        // ...
    }

    this.doFunc = func;
}
var obj = new MyObject();

// 1.进入myFunc，取func()的一个实例
myFunc.call(obj);
// 2. 套取函数实例的一个应用，暂存
var func = obj.doFunc;
// 3.再次进入myFunc，取func()的一个实例
myFunc.call(obj);
// 4.比较两次取得函数实例，结果显示false，表明是不同的实例
alert(func === obj.doFunc)
// 5.显示true，表明两个函数的代码块完全相同
alert(func.toString() == obj.doFunc.toString())
```

#### 4.6.1.3 （在被调用时），每个函数实例至少拥有一个闭包
闭包是对应于运行期的函数实例，而不是对应函数（代码块）的。由函数对应于函数实例，那么
只需要分析哪些情况下产生实例，就可以清楚地知道运行的闭包环境。  
对象的实例只持有原型中的方法的一个引用，因此不产生（方法）函数的实例。
构造器函数会产生多个函数实例。
```JS
// 构造器函数
function MyObject() {
    var instance_data = 100;
    this.getInstanceData = function () {
        return instance_data;
    }

    this.setInstanceData = function (v) {
        instance_data = v;
    }
}

// 使用一个匿名函数去修改构造器的原型MyObject.prototype，以访问该匿名函数中的upvalue
void function() {
    var class_data = 5;
    this.getClassData = function () {
        return class_data;
    }
    this.setClassData = function (v) {
        class_data = v;
    }
}.call(MyObject.prototype);

// 创建对象
var obj1 = new MyObject();
var obj2 = new MyObject();

// 输出100
// 表明obj2与obj1的getInstanceData是不同的函数实例，因此在访问不同的闭包的upvalue
obj1.getInstanceData(10);
alert(obj2.getInstanceData());

// 输出20
// 表明obj与obj1的getClassData是同样一个函数实例，因此在访问相同的upvalue
obj1.setClassData(20);
alert(obj2.getClassData());
```
除了构造对象实例的情况，我们也常常在函数中将内部函数作为返回值，其随函数的执行次数产
生多个函数实例。
```JS
function aFunc() {
    function MyFunc() {
        // ...
    }
    return MyFunc;
}
var f1 = aFunc();
var f2 = aFunc();

// 显示false 
alert(f1 === f2);
```
也可以通过比较麻烦的方法返回同一个函数实例。
```JS
var aFunc = function () {
    var MyFunc = function () {

    }

    // 返回一个函数到aFunc
    return function () {
        return MyFunc;
    }
}()

// 多次调用aFunc将得到MyFunc的同一个实例
var f3 = aFunc();
var f4 = aFunc();

// 显示true
alert(f3 === f4);
```
在这个例子中，实际上在aFunc内部创建了一个匿名函数，这个匿名函数（即使是多个实例）访
问upvalue时，将会得到相同的数据。因此多次调用aFUnc时，就会得到同一个MyFunc实例--
匿名函数的那个实例。  
以上各种形式，本质上就是“产生”与“不产生”函数实例两种形式，进而形成两种闭包、两种保护
数据和提供运行上下文环境的形式。

### 4.6.2 闭包与调用对象
《JavaScript权威指南》（第四版）对“调用对象”做出了三点说明：
* 其4.6小节中说，对象属性与变量没有本质区别。
* 其4.6.1小节中说，全局变量其实是“全局对象（global object）”的属性
* 其4.6.2小节中说，局部变量其实是“调用对象（call object）”的属性
为了解释上述话题，《JavaScript权威指南》引入“JavaScript执行环境（执行上下文），
Execution Context）的概念。这其中说到的“全局对象（Global Object）”与“调用对象（
Call Object）”其实都是指图4-6中的ScriptObject结构。
##### 图4-6 闭包相关元素（调用对象、上下文环境）的内部数据结构
```JS
TheContext = {
    type: 'FUNCTION',
    name: 'myFunc',
    params: [...],
    body: ScriptObject
}
// 对应TheContext中的body
ScriptObject = {
    type: 'SCRIPT',
    varDecls: [...],
    funDecls: [...],
    source: '...'
}

function myFunc(x, y, z) {
    // 以下对应ScriptObject中的VarDecls
    var i, j, k;
    var m = 100;
    var foo = function () {

    }

    // 以下对应ScriptObject中的funDecls
    function func() {

    }

    // 以下对应ScriptObject中的source
    i = m * 100;
    if (...) {
        ...
    }
}
```
图4-6中，TheContext结构只描述函数作为对象时的外在表现，例如名称是myFunc，参数有哪
几个，等等。它的body指向一个ScriptOBject，这个ScriptObject就包含了函数代码体中全
部的语法分析结构，包括内部变量表（varDecls）和内嵌函数表（funDecls），以及除此之外
的全部代码（source）。  
所谓“调用对象”，是指当前正在调用函数的ScriptObject结构；而所谓“全局对象”，是指系统
全局环境下的一个ScriptObject结构。下面讲述有关该结构的基本规则。

#### 4.6.2.1 “调用对象”的局部变量维护规则
规则一：在函数开始执行时，varDelcs中所有值将被置为undefined。因此我们我们无论如何
访问函数，变量初始值总是undefined。例如：
```JS
// 变量初始化
function myFunc() {
    alert(i);
    var i = 100;
}

// 输出值总是undefined
myFunc();
myFunc();
```
由于varDecls总在语法分析阶段就已经创建好了，因此在myFunc()内部，即使是在“var i”这
个声明之前访问该变量，也不会有语法错误，而是访问到位于ScriptObject结构内varDecls中
该变量的初值：undefined。由于varDecls总在执行前被初始化，因此第二次调用myFunc()时，
值仍是undefined。  
规则二：函数执行结束并退出时，varDecls不被重置。正因为varDecls不被重置，所以
JavaScript中的函数能够提供“在函数内保存数据”这种函数式语言特性。该规则与规则一不冲
突，上例中第二次调用myFunc()时，没有显示“在函数内所保存的数据”的原因是：第二次执行
函数时，在进入函数前varDecls被再次初始化了。  
规则三：函数内部数据持续（即“在函数内保存数据”）的生存周期，取决于该函数实例是否存在
活动引用---如果没有，则“调用对象（ScriptObject）”被销毁（即内存回收）。

#### 4.6.2.2 “全局对象”的变量维护规则
ScriptObject结构树对于“全局对象”来说，仍然是完全适用的。唯一不同的是，从代码的语义
分析上，我们找不到一个全局的“TheContext”结构。
不过在JavaScript引擎内部，这个全局的TheContext结构仍然存在。这种情况下，我们可以把
全局代码看做是某个函数中的“SCRIPT”代码块。基本结构如下。
##### 全局闭包相关元素（全局对象、上下文环境等）的内部数据结构
```JS
TheContext = {
    inFunction: false
}

ScriptObject = {
    type: 'SCRIPT',
    varDecls: [...],
    funDecls: [...],
    source: '...'
}

// function HostOrEngine() {
    // 对应ScriptObject中的varDecls
    var ...;
    var ...;

    // 对应ScriptObject中的funDecls
    function ...() {

    }

    // 对应ScriptObject中的source
    // 代码行...
    // 代码行...
//}
```

全局变量维护规则与关于“调用对象”的变量维护规则并不冲突。但由于（虚构的）HostOrEngine
()存在着特殊性，因此：
* 由于该函数从来不被再次进入，因此不会被重新初始化。
* 由于该函数仅有一个被系统持有的实例，因此它自身和内部数据总不被销毁。
由于这些特殊性，下面关于生存周期的讨论中将不包括“全局对象”。

#### 4.6.2.3 函数闭包与“调用对象”的生存周期
上述“调用对象”其实在语法分析期就可以得到。有了这个在语法分析期得到的ScriptObject作为
原型，接下来事情就好办了。因为在运行期该函数实例有一个函数闭包。所以执行它时，引擎将会：
* 创建一个函数实例
* 为该函数实例创建一个闭包
* 为该函数实例（及其闭包）的运行环境从ScriptObject复制一个“调用对象”
因此这三个运行期结构总是一体出现的，一般情况下看起来就像处于一个生存周期之中，但有特殊
情况。我们先讨论这种闭包与“调用对象”的生存周期，依赖于具体函数实例被引用、释放引用和销
毁的周期的情况。
```JS
function up_level() {
    var x = 100;
    var f = function () {...}
    // ...
    function myFunc() {
        var y = 20 + d;
        f();
        // ...
    }

    myFunc(x);
    // ...
}
```
myFunc()访问了两个存在依赖的变量，其一是参数d，通过函数入口传入。这种情况下，它有可能
在函数内被持有，或仅做求值运算。但在这个例子中：
```JS
// 干预局仅将参数d用作复制运算，在myFunc()闭包退出后d的引用状态将被复位
var y = 20 + d;
```
这说明变量x在myFunc(x)中被没有被持有。  
但第二个变量f不同，是在闭包中通过upvalue访问到up_level()中的变量。接下来的问题是：由
于f是闭包外的引用，因此当函数myFunc()还存活时，函数up_level()也必须存活。而且由于
JavaScript是动态语言，因此在up_level()的代码体中可能随时会修改变量f；又由于myFunc()
可能倍外部其他变量引用，因此在up_level()执行结束后，变量f也不应该被清除（这正是函数式
语言中函数闭包的特性）。  
因此一个闭包A使用了uplevel，那么uplevel所在的闭包B，就为A所依赖。  
除了在闭包内通过标识符显示地引用upvalue，从而导致闭包与闭包间的生存周期关联之外，还有
一种导致关联的情况。前面讨论参数d提到“（参数）可能在函数内被持有，或者仅做求值运算”，
其中的“导致引用的情况”，也导致闭包间产生关联关系。例如：
```JS
function up_level() {
    var f = function() {...};
    function myFunc(foo) {
        var _foo = foo;
        // ...
        function aFunc() {
            _foo();
        }
    }

    myFunc(f);
}
```
在这个例子中，函数f被myFunc()中的变量_foo持有了一个引用。尽管“对函数外无副作用”，
且函数f是通过入口参数传递的，但仍然不可避免地进行了引用计数。前例中使用的代码是：
```JS
var x = 100;
function myFunc(d) {
    var y = 20 + d; // d是入口参数，传入值类型变量x
}
```
而在本例中的代码是：
```JS
var f = function() {...};
function myFunc(foo) {
    var _foo = foo; // foo是入口参数，传入引用类型变量f
}
```
两个例子中，传入的数据类型和函数内使用方法都不一致。真正导致闭包持有外部变量的原因
是：当foo是一个引用，且被闭包内的某个变量赋值、传递或收集（例如数组的push()操作）。  
由于是动态语言的缘故，一个变量/入口参数是否为引用类型只能在运行期动态地获得，而无法
通过代码的上下文语义来分析。因此应该知道“引用与释放引用”的运算是运行期的、难以静态
推演的行为。