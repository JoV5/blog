## 4.7 【ES5】严格模式与闭包
本质上来说，在“一段代码开始处加入指示前缀（Directive Prologue）”，其真实的含义就
是：让相应的作用域运行在严格模式下。  
这里的作用域有两个与闭包有关，即“全局作用域--全局闭包”，以及“局部作用域--函数闭包”。
它们分别指如下情况：
* 全局闭包： 在全局代码的开始处加入指示前缀
* 函数闭包： 在函数声明代码开始处加入指示前缀
* 函数闭包： 在new Function()所传入的body参数块开始处加入指示前缀
另外，在eval()所执行的代码处加入指示前缀，那么严格模式将只影响到eval()所执行的代码
本身，而不影响eval()所在位置的闭包环境。在表达式中使用标识为严格模式的函数作为运算
元，并不会导致当前代码--表达式或语句变为安全模式。  
严格模式下的代码总会运行在全局闭包或函数闭包中。这意味着这些代码必然面临这两种执行环
境（执行上下文，Execution Context）。进一步说，它也就必然面临两套标识符（变量）：  
* 如果代码运行在全局闭包中，则它仅面临全局闭包中的标识符。
* 如果代码运行在函数闭包中，则它将面临当前函数闭包及闭包链（当前闭包一直到顶层的全局
闭包）上的全部标识符。

### 4.7.1 严格模式下的执行限制
1. 在严格模式下向不存在的标识符赋值将导致“引用异常（ReferenceError）”，
而在非严格模式下将会（隐式地）在全局闭包中创建该标识符并完成赋值运算。
2. 运算符处理一些不可处理的操作数时，将导致“类型异常（TypeError）”，
表明操作数是不适当的类型或具有不适当的属性描述符性质。例如：
```js
var obj = {x: 100};
// 禁例2.1：当前对象是不可扩展的（isExtensible为真），像不存在的属性赋值
Object.preventExtensions(obj);
obj.y = 100;

// 禁例2.2：当对象是不可删除属性的（isSealed或isFrozen为真），尝试删除属性
Object.seal(obj);
delete obj.x;

// 禁例2.3：删除某些不能删除的系统属性，标识符或configureable性质为false的属性
delete Function.prototype;
delete eval;

// 禁例2.4：写只读属性（包括getter-only properties）
```