# DOM编程

## 浏览器中的DOM
**文档对象模型**（DOM）是一个独立于语言的，用于操作XML和HTML文档的程序接口（API）。

他在浏览器中的接口是用JavaScript实现的。客户端脚本编程大多数时候是在和底层文档（underlying document）打交道，DOM就成为现在JavaScript编码中的重要部分。

浏览器中通常会把DOM和JavaScript独立实现。

#### 天生就慢
两个相互独立的功能只要通过接口彼此连接，就会产生消耗。访问DOM次数越多，消耗越多。因此应尽可能减少DOM访问，努力待在ECMAScript岛上。

## DOM访问与修改
减少访问DOM的次数，把运算尽量留在ECMAScript这一端处理。

### innerHTML对比DOM方法
相处无几，新版浏览器DOM更快。

### 节点克隆
使用DOM方法更新页面内容的另一个途径是克隆已有元素，而不是创建新元素--换句话说，就是使用`element.cloneNode()`（element表示已有节点）替代`document.createElement()`。

大多数浏览器中，节点克隆更有效率，但也不是特别明显。可以先创建需要重复的元素，然后重复拷贝操作，这样的运行结果只稍快一点。

### HTML集合
HTML集合是包含了DOM节点引用的类数组对象。以下方法的返回值就是一个集合。
* document.getElementByName()
* document.getElementByClassName()
* document.getElementByTabName()

下面的属性同样返回HTML集合：
* document.images
* document.links
* document.forms
* document.forms[0].elements

以上方法和属性的返回值为HTML集合对象，是一个类似数组的列表。
它们并不是真正的数组（因为没有push()货slice()之类的方法），但提供了一个类似数组中的length属性，并且还能以数组索引的方式访问列表中的元素。

事实上，HTML集合一直与文档保持着连接，每次你需要最新的信息时，都会重复执行查询的过程，哪怕只是获取集合里的元素个数（length）也是如此。这正是低效之源。

#### 昂贵的集合
在循环条件控制语句中读取数组的length属性是不推荐的做法。读取一个集合的length比读取普通数组的length要慢得多，因为每次都要重新查询。

很多情况下如果只需要遍历一个相对较小的集合，那么缓存length就够了。但由于遍历数组比遍历集合快，因此如果先将集合元素拷贝到数组中，那么访问它的属性会更快，但这会多遍历一次集合，因此需要适当的使用数组拷贝。

#### 访问集合元素时使用局部变量
一般来说，对于任何类型的DOM访问，需要多次访问同一个DOM属性或方法需要多次访问时，最好使用一个局部变量缓存此成员。当遍历一个集合时，第一优化原则是把集合存储在局部变量中，并把length缓存在循环外部，然后，使用局部变量替代这些需要多次读取的元素。

## 遍历DOM

### 获取DOM元素
通常你需要从某一个DOM元素开始，操作周围的元素，或者递归查找所有子节点。可以使用childNodes得到元素集合，或者使用nextSlibing来获取每个相邻元素。

这两种方法的运行时间几乎相等，在IE中nextSlibing比childNode表现优异。

### 元素节点
DOM元素属性诸如childNodes，firstChild和nextSlibing并不区分元素节点和其他类型节点，比如注释和文本节点（通常只是两个节点间的空格）。在某些情况下，只需访问元素节点，因此在循环中很可能需要检查返回节点的类型并过滤掉非元素节点。这些类型检查和过滤其实是不必要的DOM操作。

大部分现代浏览器提供的API只返回元素节点。如果可用的话推荐使用这些API，因为它们的执行效率比自己在JavaScript代码中实现过滤效果要高。

#### 能区分元素节点（HTML标签）和其他节点的DOM属性
| 属性名 | 被替代的属性 
| :-: | :-:
| children | childNodes 
| childElementCount | childNodes.length
| firstElemntChild | firstChild
| lastElementChild | lastChild
| nextElementChild | nextSlibing
| previousElemntSlibing | previousSlibing

IE6、7、8只支持children属性。

使用children替代childNodes会更快，因为集合项更少。

### 选择器API
`querySelectorAll()`方法使用CSS选择器作为参数并返回一个NodeList--包含着匹配节点的类数组对象。这个方法不返回HTML集合，因此返回的节点不会对应实时的文档结构。这也避免了之前讨论的HTML集合引起的性能问题。

如果需要处理大量组合查询，使用`querySelectorAll()`的话会更有效率。

## 重绘与重排
浏览器下载完页面中的所有组件--HTML标记、JavaScript、CSS、图片--之后会解析并生成两个内部数据结构：
* **DOM树** 表示页面结构
* **渲染树** 表示DOM节点如何显示

DOM树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点（隐藏的DOM元素在渲染树中没有对应的节点）。渲染树中的节点被称为“帧（frames）”或“盒（boxes）”，符合CSS模型的定义，理解页面元素为一个具有内边距（padding）、外边距（margins）、边框（borders）和位置（position）的盒子。一旦DOM和渲染树构建完成，浏览器就开始显示（绘制“paint”）页面元素。

当DOM的变化影响了元素的几何属性（宽和高）--比如改变框宽度或给段落增加文字，导致行数增加--浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为“**重排**（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为“**重绘**（repaint）”。

并不是所有的DOM变化都会影响几何属性。例如，改变一个元素的背景色并不会影响它的宽高。在这种情况下，只会发生一次重绘（必须要重排），因为元素的布局并没有改变。重绘和重排都是代价昂贵的操作，它们会导致Web应用程序的UI'反应迟钝。所以应尽可能减少这类过程的发生。

### 重排何时发生
下述情况会发生重排：
* 添加或删除可见的DOM元素。
* 元素位置改变
* 元素尺寸改变（包括外边距、内边距、内框宽度、宽度、高度等属性改变）。
* 内容改变，例如：文本改变或图片被另一个不同尺寸的图片代替。
* 页面渲染器初始化。
* 浏览器窗口尺寸改变。
根据改变的范围和程度，渲染树中或大或小的部分也需要重新计算。有些改变会触发整个页面重排：例如，滚动条的出现。

### 渲染树变化的排队与刷新
由于每次重排都会产生计算消耗，大多数浏览器通过队列修改并批量执行来优化重排过程。然而，你可能会（经常不知不觉）强制刷新队列并要求计划任务立刻执行。获取布局信息的操作会导致队列刷新，比如以下方法：
* offsetTop、offsetLeft、offsetWidth、offsetHeight
* scrollTop、scrollLeft、scrollWidth、scrollHeight
* clientTop、clientLeft、clientWidth、clientHeight
* getComputedStyle()（currentStyle inIE）
以上属性和方法需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的“待处理变化”并触发重排以返回正确值。

在修改样式的过程中，最好避免使用上面列出的属性。它们都会刷新渲染队列，即使你是在获取最近未发生改变的或者与最新改变无关的布局信息。

### 最小化重绘和重排
重绘和重排可能代价非常昂贵，因此一个好的提高程序响应速度的策略就是减少此类操作的发生。为了减少发生次数，应该合并多次对DOM和样式的修改，然后一次处理掉。

#### 改变样式
合并所有的改变然后一次处理，这样只会修改DOM一次。使用cssText属性可以实现。修改cssText属性并覆盖了已存在的样式信息，因此如果想保留现有样式，可以把它附加在cssText字符串后面。

另一个一次性修改样式的办法就是修改CSS的class名称，而不是修改内联样式。

#### 批量修改DOM
当你需要对DOM元素进行一系列操作时，可以通过以下步骤来减少重绘和重排的次数：
1. 使元素脱离文档流。
2. 对其应用多重改变。
3. 把元素带回文档中。

该过程会触发两次重排--第一步和第三步。如果忽略这两个步骤，那么在第二步所产生的任何修改都会触发一次重排。

有三种基本方法可以使DOM脱离文档：
1. 隐藏元素，应用修改，重新显示。使用`display`。
2. 使用文档片段（document fragment）在当前DOM之外构建一个字数，再把它拷贝回文档。使用`document.createDocumentFragment()`。
3. 将原始元素拷贝到一个脱离文档流的节点中，修改副本，完成后再替换原始元素。使用`cloneNode()`。

推荐尽可能使用文档片段，因为它们所产生的的DOM遍历和重排次数最少。

### 缓存布局信息
如前文所述，浏览器尝试通过队列化修改和批量执行的方式最小化重排次数。当你查询布局信息时，比如获取偏移量（offsets）、滚动位置（scroll values）或计算出的样式值（computedstyle values）时，浏览器为了返回最新值，会刷新队列并应用所有变更。最好的做法是尽量减少布局信息的获取次数，获取后把它赋值给局部变量，然后再操作局部变量。

### 让元素脱离文档流
一般来说，重排只影响渲染树的一小部分，但也可能影响很大的部分，甚至整个渲染树。浏览器所需要重排的次数越少，应用程序的响应速度就越快。使用以下步骤可以避免页面的大部分重排：
1. 使用绝对位置定位页面的动画元素，将其脱离文档流。
2. 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。
3. 当动画结束时，恢复定位从而只会下移一次文档的其他元素。

### IE和:hover
从IE7开始，IE允许在任何元素（严格模式下）上使用:hover这个CSS伪选择器。然后，如果你有大量元素使用`:hover`，那么会降低响应速度。此问题在IE8中更为明显。

## 事件委托
当当页面存在大量元素，而且每一个都要一次货多次绑定事件处理器时，这种情况可能会影响性能。

一个简单而优雅的处理DOM事件的技术是事件委托，它基于这样一个事实：事件逐层冒泡并能被父级元素捕获。使用事件代理，只需给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。

根据DOM标准，每个事件都需要经历三个阶段：
* 捕获
* 到达目标
* 冒泡

## 小结
* 最小化DOM访问次数，尽可能在JavaScript端处理
* 如果需要多次访问某个节点，请使用局部变量存储它的引用
* 小心处理HTML集合，因为它实时连系着底层文档。把集合的长度缓存到一个变量中，并在迭代中使用它。如果需要经常操作集合，建议把它拷贝到一个数组中。
* 如果可能的话，使用速度更快的API，比如`querySelectorAll()`和`firstElementChild`。
* 要留意重绘和重排；批量修改样式时，“离线”操作DOM树，使用缓存，并减少访问布局信息的次数。
* 动画中使用绝对定位，使用拖放代理。
* 使用事件委托来减少事件处理器的数量。