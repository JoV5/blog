# 第4章 算法和流程控制

## 循环

### 循环的类型
ECMA-262标准第三版定义了JavaScript的基本语法和行为，其中有四种循环类型。
1. `for`循环
2. `while`循环
3. `do-while`循环
4. `for-in`循环 可以枚举任何对象的属性名

### 循环性能
在这四种循环类型中，只有`for-in`循环比其他几种明显要慢，每次迭代操作会同时搜索实例或原型属性，产生更多开销。应避免使用'for-in'循环。不要使用`for-in`来遍历数组成员。

可通过减少以下两个因素的开销来提升循环的整体性能。
* 每次迭代处理的事物
* 迭代的次数

#### 减少迭代的工作量
可以通过减少属性查找和倒序循环。
> 当循环复杂度为O(n)时，减少每次迭代的工作量是最有效的方法。当复杂度大于O(n)，建议着重减少迭代次数。

#### 减少迭代次数
最广为人知的一种限制迭代次数的模式为“达夫设备（Duff's Device）”，它是一个循环体展开技术，它使得一次迭代中实际执行了多次迭代的操作。

### 基于函数的迭代
ECMA-262标准第四版引入了一个新的原生数组方法：`forEach()`。此方法遍历一个数组的所有成员，并在每个成员上执行一个函数。要运行的函数作为参数传给`froEach()`，并在调用时接受三个参数，分别是：当前数组项的值、索引以及数组本身。

但它比基于循环的迭代要慢一些。对每个数组项调用外部方法所带来的开销是速度慢的主要原因。


## 条件语句

### `if-else`对比`switch`
使用`if-else`还是`switch`，最流行的方法是基于测试条件的数量，条件数量越大，越倾向于使用`switch`而不是`if-else`。通常归结于代码的易读性。

这两个语句的主要性能区别是：当条件语句增加时，`if-else`性能负担增加的程度比`swicth`要多。因此，我们自然倾向于条件数量较少时使用`if-else`，条件数量较多时使用`swicth`。

通常来说，`if-else`适用于判断两个离散值或几个不同的值域。当判断多于两个离散值时，`swicth`语句是更佳选择。

### 优化`if-else`
优化`if-else`的目标是：最小化达到正确分支前所需判断的条件数量。最简单的优化方法是确保最可能出现的条件放在首位。

另一种减少条件判断的方法是把`if-else`组成的一系列嵌套的`if-else`语句。使用单个庞大的`if-else`通常会导致运行缓慢，因为每个条件都需要判断。

### 查找表
JavaScript中可以使用数组和普通对象来构建查找表，通过查找表访问数据比用`if-else`或`switch`快很多，特别是在条件语句数量很大的时候。

当你使用查找表时，必须完全抛弃条件判断语句。这个过程变成数组查询或者对象成员查询。查询表的一个主要优点是：不用书写任何条件判断语句，即便候选值数量增加时，也不会产生额外的性能开销。

当单个键和单个值之间存在逻辑映射时，查找表的优势就能体现出来。`switch`语句更适合于每个键都需要对应一个独特的的动作或一系列动作的场合。

## 递归
使用递归可以把复杂的算法变得简单。递归函数潜在的问题是终止条件不明确或缺少条件会导致函数长时间运行，并使得用户界面处于假死状态。而且，递归函数还可能遇到浏览器的“调用栈限制”（Call stack size limites）。

### 调用栈限制
JavaScript引擎支持的递归数量与JavaScript调用栈大小直接相关。

### 递归模式
当遇到调用栈大小限制时，第一步应该先检查代码中的递归实例。有两种递归模式值得注意。第一种是直接递归模式，即函数调用自身。另一种模式称为“隐伏模式”，两个函数相互调用，形成一个无限循环。

大多数调用栈错误斗鱼这两种模式有关。最常见的导致栈溢出的原因是不正确的终止条件，因此定位模式错误的第一步是验证终止条件。如果终止条件没问题，那么可能是算法中包括太多层递归，为了在浏览器中安全地工作，建议改用迭代、Memoization、或者结合两者使用。

## 迭代
任何递归能实现的算法同样可以用迭代来实现迭代算法通常包含几个不同的循环，分别对应计算过程的不同方面，这也会引入它们自身的性能问题。然而，使用优化后的循环替代长时间运行的递归函数可以提升性能，因为一个循环比反复调用一个函数的开销要少得多。

## Memoization
Memoization是一种避免重复工作的方法，它缓存前一个计算结果供后续计算使用，避免可重复工作，这使得它成为递归算法中有用的技术。
可以使用一个memoize()函数：
```js
function memoize(fundamental, cache) {
    cache = cache || {};

    var shell = function (arg) {
        if (!cache.hasOwnProperty(arg) {
            cache[arg] = fundamental(arg);
        })
        return cache[arg];
    };

    return shell;
}
```
memoize()函数接受两个参数：一个是需要增加缓存功能的函数，一个是可选的缓存对象。然后创建了一个封装了原始函数（fundamental）的外壳（shell）函数，以确保只有当一个结果值之前从未被计算过时才会产生新的计算。最后返回这个外壳函数。

这种通用的Memoization与手工更新给定函数的算法相比优化要差一些。因为memoize()函数会缓存特定参数的函数调用结果。当代码以相同的参数多次调用外壳函数时才能节省时间。因此，当Memoization函数存在显著性能问题时，最好有针对性地手工实现它，而不是直接用通用Memoization方案。

## 小结
JavaScript和其他编程语言一样，代码的写法和算法回来影响运行时间。与其他语言不同的是，JavaScript可用资源有限，因此优化技术更为重要。
* for、while、do-while循环性能特性相当，并没有一种循环类型明显快于或慢于其他类型。
* 避免使用for-in循环，除非你需要遍历一个属性数量为止的对象。
* 改善循环性能的最佳方式是减少每次迭代的运算量和减少循环迭代次数。
* 通常来说，switch总是比if-else快，但并不总是最佳解决方案。
* 在判断条件较多时，使用查找表比if-else和switch更快。
* 浏览器的调用栈大小限制了递归算法在JavaScript中的应用；栈溢出错误会导致其他代码中断运行。
* 如果你遇到栈溢出错误，可将方法改为迭代算法，或使用Memoization来避免重复计算。