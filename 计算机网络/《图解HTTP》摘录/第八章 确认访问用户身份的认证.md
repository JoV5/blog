## 第八章 确认访问用户的身份的认证

### 8.1 何为认证
#### HTTP使用的认证方式
##### HTTP/1.1使用的认证方式如下所示。
* BASIC认证（基本认证）
* DIGEST认证（摘要认证）
* SSL客户端认证
* FromBase认证（基于表单认证）

### 8.2 BASIC认证
从HTTP/1.1就定义的认证方式。即便现在仍有一部分的网站会使用这种认证方式。
是Web服务器与通信客户端之间进行的认证方式。

#### BASIC认证的认证步骤
1. 当请求资源需要BASIC认证时，服务器会随状态码401 Authorization Required，返回带
WWW-Authenticate首部字段的响应。该字段内包含认证的方式（BASIC）及Request-URI安全域字符串。
2. 接收到状态码401的客户端为了通过BASIC认证，需要将用户ID及密码发送给服务器。发送的
字符串内容是由用户ID和密码构成，两者中间以冒号（：）连接后没，再经过Base64编码处理。
3. 接收到包含首部字段Authorization请求的服务器，会对认证信息的正确性进行验证。
如验证通过，则返回一条包含Request-URI资源的响应。

BASIC认证虽然采用Base64编码方式，但不是加密处理。不需要任何附加信息即可对其编码。
换言之，由于明文解码后就是用户ID和密码，在HTTP等非加密通信的线路上进行BASIC认证的
过程中，如果被人窃听，被盗的可能性极高。  
另外，除此之外再想进行一次BASIC认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。
BASIC认证使用上不够便捷灵活，且达不到多数网站期望的安全性等级，因此并不常用。

### 8.3 DIEEST认证
为弥补BASIC认证存在的弱点，从HTTP/1.1就有了DIGEST认证。DIGEST认证同样使用质询/响应
的方式（challenge/response），但不会像BASIC认证那样直接发送明文密码。
所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方接收到的
质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。  
因为发送给对方的只是响应摘要及由质询码产生的结果，所以比起BASIC认证，密码泄露的
可能性就降低了。  

##### DIGEST认证的认证步骤
1. 请求需认证的资源时，服务器会随状态码401 Authorization Required，返回带
WWW-Authenticate首部字段的响应。该字段内包含质问方式认证所需的临时质询码（随机数，nonce）。  
首部字段WWW-Authenticate内必须包含realm和nonce这两个字段的信息。客户端就是依靠向
服务器回送这两个值进行认证的。  
nonce是一种每次随返回的401响应生成的任意随机字符串。该字符串通常推荐由Base64编码的
十六进制数的组成形式，但实际内容依赖服务器的具体实现。
2. 接收到401状态码的客户端，返回的响应中包含DIGEST认证必须有的首部字段Authorization信息。  
首部字段Authorization内必须包含username、realm、nonce、uri和response的字段信息。
其中，realm和nonce就是之前从服务器接收到的响应中的字段。  
username是realm限定范围内可进行认证的用户名。  
uri（digest-uri）即Request-URI的值，但考虑到经代理转发后Request-URI的
值可能被修改，因此事先会复制一份副本保存在uri内。  
response也可叫做Request-Digest，存放经过MD5运算后的密码字符串，形成响应码。
3. 接收到包含首部字段Authorization请求的服务器，会确认认证信息的正确性。认证通过后
则返回包含Request-URI资源的响应。  
并且这时会在首部字段Authentication-Info写入一些认证成功的信息。  
DIGEST认证提供了高于BASIC认证的安全等级，但是和HTTPS的客户端认证相比仍旧很弱。
DIGEST认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。 
和BASICE认证一样，使用上不便捷且达不到多数Web网站对高度安全等级的追求标准，适用范围有限。

### 8.4 SSL客户端认证
从使用用户ID和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。
但如果用户ID和密码被盗，就有可能能被第三者冒充。利用SSL客户端认证则可避免该情况的发生。  
SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，
服务器可确认访问是否来自登录的客户端。 

#### 8.4.1 SSL客户端认证的认证步骤
为达到SSL客户端认证的目的，需要事先先将客户端证书分发给客户端，且客户端必须安装此证书。  
1. 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文
方式发送给服务器。
3. 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信。

#### 8.4.2 SSL客户端认证采用双因素认证
在多数情况下，SSL客户端认证不会仅靠证书完成认证，一般会基于表单认证组合形成一种双因素认证
来使用。所谓双因素认证就是指，认证过程不仅需要密码这一因素，还需要申请认证者提供其他
特有信息，从而作为另一个因素，与其组合使用的认证方式。  
换言之，第一个认证因素的SSL客户端证书用来认证客户端计算机，另一个认证因素的密码则用来
确定这是用户本人的行为。  
通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算访问服务器。

#### 8.4.3 SSL客户端客户端认证必要的费用
使用SSL客户端认证需要用到客户端证书。而客户端证书需要支付一定的费用采用使用。这里的费用
包括从认证机构购买客户端证书的费用，以及服务器运营者为保证自己搭建的认证机构安全运营产生的费用。

### 8.5 基于表单认证
基于表单的认证方法并不是在HTTP协议中定义的。客户端会向服务器上的Web应用程序发送登录
信息（Credential），按登录信息的验证结果认证。  
多数情况下，输入已事先登录的用户ID（通常是任意字符串或邮件地址）和密码等登录信息，
发送给Web应用程序，基于认证结果来决定是否成功。

#### 8.5.1 认证多半为基于表单认证
对于Web网站的认证功能，能够满足其安全使用级别的标准规范并不存在，所以只好使用由Web
应用程序各自实现基于表单的认证方式。  
不具备共同标准规范的表单认证，在每个Web网站上都会有各自不同的实现方式。如果是全面
考虑过安全性能而实现的表单认证，那就能够具备高度的安全等级。但在表单认证的实现中
存在问题的网站也屡见不鲜。

#### 8.5.2 Session管理及Cookie应用
基于表单认证的标准规范尚未有定论，一般会使用Cookie来管理Session（会话）。  
基于表单认证本身是通过服务器的Web端的Web应用，将客户端发送过来的用户ID和密码与
之前登陆过的信息做匹配来进行认证。  
但HTTP是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。于是我们会
使用Cookie来管理Session，以弥补HTTP协议中不存在的状态管理功能。

1. 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法吧请求
发送给服务器。而这时会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。
2. 服务器回放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行
身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。  
向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID。  
你可以把Session ID想象成一种用以区分不同用户的等位号。如果Session ID被第三方盗走，
对方就可以伪装成你的身份进行恶意操作了。为了防止Session ID被盗或猜出，应使用
难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。  
另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上httponly属性。
3. 客户端收到从服务器端发送来的Sessrion ID后，会将其作为Cookie保存在本地。下次
向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID也随之发送到服务器。
服务器端可通过验证接收到的Session ID识别用户和其认证状态。 

不仅给予表单认证的登录信息及认证过程都无标准化的方法，服务器端应如何保存用户提交的
密码及登录信息等也没有标准化。  
通常，一种安全的保存方法是，先利用给秘密加盐（salt）的方式增加额外信息，再利用
散列（hash）函数计算出散列值后保存。但是也经常看到直接保存明文密码的做法，这会有
导致泄露的风险。


